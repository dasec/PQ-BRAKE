<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PQ-BRAKE: operations/Crypto.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PQ-BRAKE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ce81d3468f62db2922d7d87035174548.html">operations</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Crypto.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;NTL/ZZ_pE.h&gt;</code><br />
<code>#include &quot;<a class="el" href="Client_8hpp_source.html">../participants/Client.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Evaluator_8hpp_source.html">../participants/Evaluator.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Server_8hpp_source.html">../participants/Server.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="oqs__cpp_8h_source.html">../oqs_cpp.h</a>&quot;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="Crypto_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a515cdfb8cd2d14ab44da177e219472ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#a515cdfb8cd2d14ab44da177e219472ba">hashSHA256</a> (const std::string &amp;plaintext)</td></tr>
<tr class="separator:a515cdfb8cd2d14ab44da177e219472ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018ac78ef05389b16a2ed65fd93183ad"><td class="memItemLeft" align="right" valign="top">NTL::ZZ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#a018ac78ef05389b16a2ed65fd93183ad">hashDigestToIntegerModQ</a> (const std::string &amp;digest_string)</td></tr>
<tr class="separator:a018ac78ef05389b16a2ed65fd93183ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af744588b55dfba1836ca682a1e3c2197"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#af744588b55dfba1836ca682a1e3c2197">hashCoefficients</a> (const NTL::ZZX &amp;secret_polynomial)</td></tr>
<tr class="separator:af744588b55dfba1836ca682a1e3c2197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d2db8c757962e84487b34b5f6bceca"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#ae8d2db8c757962e84487b34b5f6bceca">rounding</a> (const NTL::ZZ_pE &amp;polynom)</td></tr>
<tr class="separator:ae8d2db8c757962e84487b34b5f6bceca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d52a7d46c433d28577eadcba131604"><td class="memItemLeft" align="right" valign="top">NTL::ZZ_pE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#ab0d52a7d46c433d28577eadcba131604">sampleSmallUniformPolynomial</a> (long long lbound, long long ubound)</td></tr>
<tr class="memdesc:ab0d52a7d46c433d28577eadcba131604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling small uniform polynomial of degree N in the range [lbound,ubound], negative values represented with modulo q.  <br /></td></tr>
<tr class="separator:ab0d52a7d46c433d28577eadcba131604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa522b8934baaa3d9991f721f82cd3765"><td class="memItemLeft" align="right" valign="top">NTL::ZZ_pE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#aa522b8934baaa3d9991f721f82cd3765">sampleBigUniformPolynomial</a> (const NTL::ZZ &amp;bound)</td></tr>
<tr class="separator:aa522b8934baaa3d9991f721f82cd3765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e095599a3bd1cb847f5dd4ffd0934a2"><td class="memItemLeft" align="right" valign="top">NTL::ZZ_pE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#a1e095599a3bd1cb847f5dd4ffd0934a2">aSampleBigUniformPolynomial</a> (const NTL::ZZ &amp;bound)</td></tr>
<tr class="separator:a1e095599a3bd1cb847f5dd4ffd0934a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e77182786b9bc38e7a53b923b6c081"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#a88e77182786b9bc38e7a53b923b6c081">OPRFWithTimings</a> (<a class="el" href="classClient.html">Client</a> *client, <a class="el" href="classEvaluator.html">Evaluator</a> *evaluator, std::vector&lt; double &gt; &amp;sampling_big_a, std::vector&lt; double &gt; &amp;sampling_small_k, std::vector&lt; double &gt; &amp;sampling_small_e, std::vector&lt; double &gt; &amp;compute_c, std::vector&lt; double &gt; &amp;sampling_small_s, std::vector&lt; double &gt; &amp;sampling_small_e_prime, std::vector&lt; double &gt; &amp;compute_a_x, std::vector&lt; double &gt; &amp;compute_c_x, std::vector&lt; double &gt; &amp;sampling_big_E, std::vector&lt; double &gt; &amp;compute_d_x, std::vector&lt; double &gt; &amp;compute_y, std::vector&lt; double &gt; &amp;rounding_y)</td></tr>
<tr class="memdesc:a88e77182786b9bc38e7a53b923b6c081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified OPRF protocol execution based on the original protocol from: "Martin R Albrecht et al. “Round-optimal verifiable oblivious pseudorandom functions from ideal lattices”. - 2021.". Includes the following: timing mechanisms for each step, sampling preliminary values, blinding and unblinding operations.  <br /></td></tr>
<tr class="separator:a88e77182786b9bc38e7a53b923b6c081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d910206f71de35f37f66b2acab93b17"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#a0d910206f71de35f37f66b2acab93b17">OPRF</a> (<a class="el" href="classClient.html">Client</a> *client, <a class="el" href="classEvaluator.html">Evaluator</a> *evaluator, bool common_values_initialized)</td></tr>
<tr class="memdesc:a0d910206f71de35f37f66b2acab93b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified OPRF protocol execution based on the original protocol from: "Martin R Albrecht et al. “Round-optimal verifiable oblivious pseudorandom functions from ideal lattices”. - 2021.". Includes the following: sampling preliminary values, blinding and unblinding operations.  <br /></td></tr>
<tr class="separator:a0d910206f71de35f37f66b2acab93b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e7c00822e434b8bda7bdf87d0e519f"><td class="memItemLeft" align="right" valign="top">oqs::bytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Crypto_8hpp.html#a05e7c00822e434b8bda7bdf87d0e519f">kyberWithTimings</a> (std::vector&lt; double &gt; &amp;timings_KeyGen, std::vector&lt; double &gt; &amp;timings_Encap, std::vector&lt; double &gt; &amp;timings_Decap, const string &amp;kyber_version)</td></tr>
<tr class="memdesc:a05e7c00822e434b8bda7bdf87d0e519f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRYSTALS-kyber KEM example function with timing code.  <br /></td></tr>
<tr class="separator:a05e7c00822e434b8bda7bdf87d0e519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1e095599a3bd1cb847f5dd4ffd0934a2" name="a1e095599a3bd1cb847f5dd4ffd0934a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e095599a3bd1cb847f5dd4ffd0934a2">&#9670;&#160;</a></span>aSampleBigUniformPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ_pE aSampleBigUniformPolynomial </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>bound</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af744588b55dfba1836ca682a1e3c2197" name="af744588b55dfba1836ca682a1e3c2197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af744588b55dfba1836ca682a1e3c2197">&#9670;&#160;</a></span>hashCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hashCoefficients </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZX &amp;&#160;</td>
          <td class="paramname"><em>secret_polynomial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a018ac78ef05389b16a2ed65fd93183ad" name="a018ac78ef05389b16a2ed65fd93183ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018ac78ef05389b16a2ed65fd93183ad">&#9670;&#160;</a></span>hashDigestToIntegerModQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ hashDigestToIntegerModQ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>digest_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a515cdfb8cd2d14ab44da177e219472ba" name="a515cdfb8cd2d14ab44da177e219472ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515cdfb8cd2d14ab44da177e219472ba">&#9670;&#160;</a></span>hashSHA256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hashSHA256 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>plaintext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cryptographic operations, hashing, LWE, Ring, etc. </p>

</div>
</div>
<a id="a05e7c00822e434b8bda7bdf87d0e519f" name="a05e7c00822e434b8bda7bdf87d0e519f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e7c00822e434b8bda7bdf87d0e519f">&#9670;&#160;</a></span>kyberWithTimings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">oqs::bytes kyberWithTimings </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>timings_KeyGen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>timings_Encap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>timings_Decap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>kyber_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CRYSTALS-kyber KEM example function with timing code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kyber_version</td><td>string representing the kyber version desired </td></tr>
    <tr><td class="paramname">timings_KeyGen</td><td>vector of time values for key generation </td></tr>
    <tr><td class="paramname">timings_Encap</td><td>vector of time values for encapsulation </td></tr>
    <tr><td class="paramname">timings_Decap</td><td>vector of time values for decapsulation</td></tr>
  </table>
  </dd>
</dl>
<p>The function does the following: generates a random fresh keypair and random shared secret, performs encapsulation, decapsulation and then checking if the decapsulation was successful. </p>
<p>if decapsulation is successful -&gt; the shared secret is returned, if it fails -&gt; a predetermined failure value is returned</p>

</div>
</div>
<a id="a0d910206f71de35f37f66b2acab93b17" name="a0d910206f71de35f37f66b2acab93b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d910206f71de35f37f66b2acab93b17">&#9670;&#160;</a></span>OPRF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX OPRF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClient.html">Client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEvaluator.html">Evaluator</a> *&#160;</td>
          <td class="paramname"><em>evaluator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>common_values_initialized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified OPRF protocol execution based on the original protocol from: "Martin R Albrecht et al. “Round-optimal verifiable oblivious pseudorandom functions from ideal lattices”. - 2021.". Includes the following: sampling preliminary values, blinding and unblinding operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>client object </td></tr>
    <tr><td class="paramname">evaluator</td><td>evaluator object </td></tr>
    <tr><td class="paramname">common_values_initialized</td><td>true if the server already published its commitment (values a,k,e,c) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88e77182786b9bc38e7a53b923b6c081" name="a88e77182786b9bc38e7a53b923b6c081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e77182786b9bc38e7a53b923b6c081">&#9670;&#160;</a></span>OPRFWithTimings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX OPRFWithTimings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClient.html">Client</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEvaluator.html">Evaluator</a> *&#160;</td>
          <td class="paramname"><em>evaluator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sampling_big_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sampling_small_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sampling_small_e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>compute_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sampling_small_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sampling_small_e_prime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>compute_a_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>compute_c_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sampling_big_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>compute_d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>compute_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rounding_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified OPRF protocol execution based on the original protocol from: "Martin R Albrecht et al. “Round-optimal verifiable oblivious pseudorandom functions from ideal lattices”. - 2021.". Includes the following: timing mechanisms for each step, sampling preliminary values, blinding and unblinding operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>client object </td></tr>
    <tr><td class="paramname">evaluator</td><td>evaluator object </td></tr>
    <tr><td class="paramname">sampling_big_a</td><td>vector of time values </td></tr>
    <tr><td class="paramname">sampling_small_k</td><td>vector of time values </td></tr>
    <tr><td class="paramname">sampling_small_e</td><td>vector of time values </td></tr>
    <tr><td class="paramname">compute_c</td><td>vector of time values </td></tr>
    <tr><td class="paramname">sampling_small_s</td><td>vector of time values </td></tr>
    <tr><td class="paramname">sampling_small_e_prime</td><td>vector of time values </td></tr>
    <tr><td class="paramname">compute_a_x</td><td>vector of time values </td></tr>
    <tr><td class="paramname">compute_c_x</td><td>vector of time values </td></tr>
    <tr><td class="paramname">sampling_big_E</td><td>vector of time values </td></tr>
    <tr><td class="paramname">compute_d_x</td><td>vector of time values </td></tr>
    <tr><td class="paramname">compute_y</td><td>vector of time values </td></tr>
    <tr><td class="paramname">rounding_y</td><td>vector of time values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8d2db8c757962e84487b34b5f6bceca" name="ae8d2db8c757962e84487b34b5f6bceca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d2db8c757962e84487b34b5f6bceca">&#9670;&#160;</a></span>rounding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZX rounding </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ_pE &amp;&#160;</td>
          <td class="paramname"><em>polynom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa522b8934baaa3d9991f721f82cd3765" name="aa522b8934baaa3d9991f721f82cd3765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa522b8934baaa3d9991f721f82cd3765">&#9670;&#160;</a></span>sampleBigUniformPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ_pE sampleBigUniformPolynomial </td>
          <td>(</td>
          <td class="paramtype">const NTL::ZZ &amp;&#160;</td>
          <td class="paramname"><em>bound</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0d52a7d46c433d28577eadcba131604" name="ab0d52a7d46c433d28577eadcba131604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d52a7d46c433d28577eadcba131604">&#9670;&#160;</a></span>sampleSmallUniformPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NTL::ZZ_pE sampleSmallUniformPolynomial </td>
          <td>(</td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>lbound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long long&#160;</td>
          <td class="paramname"><em>ubound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sampling small uniform polynomial of degree N in the range [lbound,ubound], negative values represented with modulo q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lbound</td><td>lower bound </td></tr>
    <tr><td class="paramname">ubound</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
